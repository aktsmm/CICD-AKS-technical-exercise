name: 3. Mongo Backup

on:
    push:
        branches: [main]
        paths:
            - ".github/workflows/backup-schedule.yml"
    schedule:
        # 毎日 02:00 JST に相当する 17:00 UTC に実行
        - cron: "0 17 * * *"
    workflow_dispatch:

permissions:
    contents: read
    id-token: write

env:
    RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
    MONGO_VM_NAME: ${{ vars.MONGO_VM_NAME != '' && vars.MONGO_VM_NAME || 'vm-mongo-dev' }}

jobs:
    trigger-backup:
        name: Run mongo dump from Azure VM
        runs-on: ubuntu-latest
        steps:
            - name: Checkout repository
              uses: actions/checkout@v4

            - name: Azure Login
              uses: azure/login@v1
              with:
                  client-id: ${{ secrets.AZURE_CLIENT_ID }}
                  tenant-id: ${{ secrets.AZURE_TENANT_ID }}
                  subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

            - name: Ensure Mongo backup script is provisioned on VM
              env:
                  MONGO_ADMIN_USER: ${{ vars.MONGO_ADMIN_USER != '' && vars.MONGO_ADMIN_USER || 'mongoadmin' }}
                  MONGO_ADMIN_PASSWORD: ${{ secrets.MONGO_ADMIN_PASSWORD }}
                  FORCE_REDEPLOY: ${{ vars.BACKUP_FORCE_REDEPLOY != '' && vars.BACKUP_FORCE_REDEPLOY || 'true' }}
              run: |
                  set -euo pipefail

                  if ! command -v jq >/dev/null 2>&1; then
                    echo "::error::jq is required but not available on PATH"
                    exit 1
                  fi

                  RG="${{ env.RESOURCE_GROUP }}"
                  VM_NAME="${{ env.MONGO_VM_NAME }}"
                  CONTAINER_NAME="backups"

                  STORAGE_ACCOUNT=$(az storage account list --resource-group "$RG" --query "[0].name" -o tsv)
                  if [ -z "$STORAGE_ACCOUNT" ] || [ "$STORAGE_ACCOUNT" = "" ] || [ "$STORAGE_ACCOUNT" = "None" ]; then
                    echo "::error::Failed to detect a storage account in resource group '$RG'"
                    exit 1
                  fi

                  if [ -z "${MONGO_ADMIN_PASSWORD:-}" ]; then
                    echo "::error::MONGO_ADMIN_PASSWORD secret is not configured"
                    exit 1
                  fi

                  if [ -z "${MONGO_ADMIN_USER:-}" ]; then
                    echo "::error::MONGO_ADMIN_USER variable is not configured"
                    exit 1
                  fi

                  extract_status() {
                    awk '/\[stdout\]/{getline; gsub(/\r/,"",$0); if(NF){print; exit}}' <<<"$1"
                  }

                  ensure_script=$(mktemp)
                  sanitized_script=$(mktemp)
                  trap 'rm -f "$ensure_script" "$sanitized_script"' EXIT

                  RAW_URL="https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/main/infra/scripts/setup-backup.sh"

                  # Fail fast when the raw script URL is unreachable (e.g., typo or private repo).
                  if ! curl -fsSI "$RAW_URL" >/dev/null; then
                    echo "::error::Failed to reach $RAW_URL"
                    exit 1
                  fi

                  USER_ESCAPED=$(printf '%q' "$MONGO_ADMIN_USER")
                  PASSWORD_ESCAPED=$(printf '%q' "$MONGO_ADMIN_PASSWORD")
                  STORAGE_ESCAPED=$(printf '%q' "$STORAGE_ACCOUNT")
                  CONTAINER_ESCAPED=$(printf '%q' "$CONTAINER_NAME")
                  FORCE_REDEPLOY_ESCAPED=$(printf '%q' "${FORCE_REDEPLOY:-false}")

                  {
                    printf '%s\n' '#!/bin/bash'
                    printf '%s\n' 'set -euo pipefail'
                    printf '%s\n' 'TARGET=/usr/local/bin/mongodb-backup.sh'
                    printf '%s\n' "FORCE_REDEPLOY=$FORCE_REDEPLOY_ESCAPED"
                    printf '%s\n' 'if [ "$FORCE_REDEPLOY" = "true" ]; then'
                    printf '%s\n' '  echo "Forcing redeploy of backup script..."'
                    printf '%s\n' '  rm -f "$TARGET"'
                    printf '%s\n' 'fi'
                    printf '%s\n' 'if [ -x "$TARGET" ] && grep -q "#!/bin/bash" "$TARGET" && grep -q "mongodb-backup" "$TARGET"; then'
                    printf '%s\n' '  echo READY'
                    printf '%s\n' '  exit 0'
                    printf '%s\n' 'fi'
                    printf '%s\n' '# Download the latest setup-backup.sh from the repository to avoid inline size limits.'
                    printf '%s\n' "RAW_URL=$RAW_URL"
                    printf '%s\n' 'tmp_dir=$(mktemp -d)'
                    printf '%s\n' 'trap '\''rm -rf "$tmp_dir"'\'' EXIT'
                    printf '%s\n' 'if ! command -v curl >/dev/null 2>&1; then'
                    printf '%s\n' '  sudo apt-get update && sudo apt-get install -y curl'
                    printf '%s\n' 'fi'
                    printf '%s\n' 'curl -fsSL "$RAW_URL" -o "$tmp_dir/setup-backup.sh"'
                    printf '%s\n' 'chmod +x "$tmp_dir/setup-backup.sh"'
                    printf '%s\n' "export MONGO_ADMIN_USER=$USER_ESCAPED"
                    printf '%s\n' "export MONGO_ADMIN_PASSWORD=$PASSWORD_ESCAPED"
                    printf '%s %s %s\n' '"$tmp_dir/setup-backup.sh"' "$STORAGE_ESCAPED" "$CONTAINER_ESCAPED"
                    printf '%s\n' 'rm -f "$tmp_dir/setup-backup.sh"'
                    printf '%s\n' 'echo DEPLOYED'
                  } > "$ensure_script"

                  cp "$ensure_script" "$sanitized_script"
                  if [ -n "${MONGO_ADMIN_PASSWORD:-}" ]; then
                    sed -i "s/${MONGO_ADMIN_PASSWORD}/***MASKED***/g" "$sanitized_script"
                  fi

                  echo '::group::Ensure script payload'
                  cat "$sanitized_script"
                  echo '::endgroup::'

                  ensure_result=$(az vm run-command invoke \
                    --resource-group "$RG" \
                    --name "$VM_NAME" \
                    --command-id RunShellScript \
                    --scripts @"$ensure_script" \
                    -o json)

                  ensure_status=$(extract_status "$(echo "$ensure_result" | jq -r '.value[0].message')")

                  if [ "$ensure_status" = "READY" ]; then
                    echo "::notice::Backup script already provisioned on $VM_NAME"
                  elif [ "$ensure_status" = "DEPLOYED" ]; then
                    echo "::notice::Backup script deployed on $VM_NAME (storage: $STORAGE_ACCOUNT)"
                  else
                    echo "::error::Unexpected status while provisioning backup script: ${ensure_status:-<empty>}"
                    echo "$ensure_result"
                    exit 1
                  fi

            - name: Execute MongoDB Backup Script on VM
              id: runbackup
              run: |
                  set -euo pipefail

                  if ! command -v jq >/dev/null 2>&1; then
                    echo "::error::jq is required but not available on PATH"
                    exit 1
                  fi

                  RG="${{ env.RESOURCE_GROUP }}"
                  VM_NAME="${{ env.MONGO_VM_NAME }}"

                  if ! az vm show --resource-group "$RG" --name "$VM_NAME" >/dev/null 2>&1; then
                    echo "::warning::VM '$VM_NAME' not found in resource group '$RG'. Skipping backup trigger."
                    {
                      echo "vm_found=false"
                      echo "stdout<<EOF"
                      echo "Skip: VM '$VM_NAME' not found in resource group '$RG'."
                      echo "EOF"
                    } >> "$GITHUB_OUTPUT"
                    exit 0
                  fi

                  invoke_vm_command_json() {
                    local script_body="$1"
                    local tmp
                    tmp=$(mktemp)
                    {
                      echo '#!/bin/bash'
                      echo 'set -euo pipefail'
                      printf '%s\n' "$script_body"
                    } > "$tmp"
                    local result
                    if ! result=$(az vm run-command invoke \
                      --resource-group "$RG" \
                      --name "$VM_NAME" \
                      --command-id RunShellScript \
                      --scripts @"$tmp" \
                      -o json); then
                      rm -f "$tmp"
                      return 1
                    fi
                    rm -f "$tmp"
                    printf '%s\n' "$result"
                  }

                  RUN_RESULT=$(invoke_vm_command_json '/usr/local/bin/mongodb-backup.sh')


                  MESSAGE=$(echo "$RUN_RESULT" | jq -r '.value[0].message')
                  EXIT_CODE=$(echo "$RUN_RESULT" | jq -r '.value[0].instanceView.exitCode // 0')

                  echo "::group::VM command output ($VM_NAME)"
                  echo "$MESSAGE"
                  echo "::endgroup::"
                  echo "::notice::MongoDB backup script finished on $VM_NAME (exit code $EXIT_CODE)"

                  if [ "$EXIT_CODE" -ne 0 ]; then
                    echo "::error::Run Command failed with exit code $EXIT_CODE"
                    exit "$EXIT_CODE"
                  fi

                  if echo "$MESSAGE" | grep -q "This is a sample script"; then
                    echo "::error::Run Command returned the placeholder sample output"
                    exit 1
                  fi

                  BACKUP_FILE=$(echo "$MESSAGE" | awk -F': ' '/^File:/ {gsub(/\r/,"",$2); print $2; exit}')
                  BACKUP_SIZE=$(echo "$MESSAGE" | awk -F': ' '/^Size:/ {gsub(/\r/,"",$2); print $2; exit}')
                  BACKUP_URL=$(echo "$MESSAGE" | awk -F': ' '/^URL:/ {gsub(/\r/,"",$2); print $2; exit}')
                  BACKUP_CURL=$(echo "$MESSAGE" | awk -F': ' '/^cURL:/ {gsub(/\r/,"",$0); sub(/^cURL: /, "", $0); print $0; exit}')

                  if [ -z "$BACKUP_FILE" ] || [ -z "$BACKUP_URL" ] || [ -z "$BACKUP_CURL" ]; then
                    echo "::error::Failed to parse backup summary from script output"
                    exit 1
                  fi

                  {
                    echo "vm_found=true"
                    echo "stdout<<EOF"
                    printf '%s\n' "$MESSAGE"
                    echo "EOF"
                    echo "backup_file=$BACKUP_FILE"
                    echo "backup_size=$BACKUP_SIZE"
                    echo "backup_url=$BACKUP_URL"
                    echo "backup_curl=$BACKUP_CURL"
                  } >> "$GITHUB_OUTPUT"

            - name: Collect Latest Backup Log
              id: log
              if: steps.runbackup.outputs.vm_found == 'true'
              run: |
                  set -euo pipefail

                  RG="${{ env.RESOURCE_GROUP }}"
                  VM_NAME="${{ env.MONGO_VM_NAME }}"

                  invoke_vm_command_message() {
                    local script_body="$1"
                    local tmp
                    tmp=$(mktemp)
                    {
                      echo '#!/bin/bash'
                      echo 'set -euo pipefail'
                      printf '%s\n' "$script_body"
                    } > "$tmp"
                    local result
                    if ! result=$(az vm run-command invoke \
                      --resource-group "$RG" \
                      --name "$VM_NAME" \
                      --command-id RunShellScript \
                      --scripts @"$tmp" \
                      -o json); then
                      rm -f "$tmp"
                      return 1
                    fi
                    rm -f "$tmp"
                    echo "$result" | jq -r '.value[0].message'
                  }

                  LOG_OUTPUT=$(invoke_vm_command_message 'tail -n 20 /var/log/mongodb-backup.log')

                  {
                    echo "log<<EOF"
                    printf '%s\n' "$LOG_OUTPUT"
                    echo "EOF"
                  } >> "$GITHUB_OUTPUT"

            - name: Collect Backup Artifacts
              id: artifacts
              if: steps.runbackup.outputs.vm_found == 'true'
              run: |
                  set -euo pipefail

                  RG="${{ env.RESOURCE_GROUP }}"
                  VM_NAME="${{ env.MONGO_VM_NAME }}"

                  invoke_vm_command_json() {
                    local script_body="$1"
                    local tmp
                    tmp=$(mktemp)
                    {
                      echo '#!/bin/bash'
                      echo 'set -euo pipefail'
                      printf '%s\n' "$script_body"
                    } > "$tmp"
                    local output
                    if ! output=$(az vm run-command invoke \
                      --only-show-errors \
                      --resource-group "$RG" \
                      --name "$VM_NAME" \
                      --command-id RunShellScript \
                      --scripts @"$tmp" \
                      -o json 2>&1); then
                      local status=$?
                      rm -f "$tmp"
                      echo "$output" >&2
                      return $status
                    fi
                    rm -f "$tmp"
                    printf '%s\n' "$output"
                  }

                  list_payload() {
                    local script="$1"
                    local raw
                    if ! raw=$(invoke_vm_command_json "$script"); then
                      return 1
                    fi

                    echo "$raw" |
                      jq -r '.value[0].message' |
                      awk '/\[stdout\]/{flag=1;next}/\[stderr\]/{flag=0}flag' |
                      sed 's/\r$//' |
                      grep -v '^[[:space:]]*Optional parameters:' |
                      sed '/^$/d'
                  }

                  first_line() {
                    echo "$1" | sed 's/\r$//' | grep -v '^[[:space:]]*Optional parameters:' | head -n 1
                  }

                  FILE_LINES=$(list_payload "ls -lh /var/backups/mongodb/mongodb_backup_*.tar.gz 2>/dev/null" || true)
                  SAS_URL=""
                  PUBLIC_URL=$(list_payload "grep 'Backup completed and uploaded to' /var/log/mongodb-backup.log | tail -n 1 | sed -e 's/.*uploaded to //'" || true)

                  PUBLIC_URL=$(first_line "$PUBLIC_URL")

                  {
                    echo "files<<EOF"
                    if [ -n "$FILE_LINES" ]; then
                      echo "$FILE_LINES" | sed 's/^/- /'
                    fi
                    echo "EOF"
                    echo "public_url=$PUBLIC_URL"
                  } >> "$GITHUB_OUTPUT"

            - name: Publish Backup Summary
              run: |
                  if [[ "${{ steps.runbackup.outputs.vm_found }}" != "true" ]]; then
                    {
                      echo "### MongoDB Backup Trigger"
                      echo "- Result: VM '${{ env.MONGO_VM_NAME }}' not found in resource group '${{ env.RESOURCE_GROUP }}'. Backup skipped."
                    } >> $GITHUB_STEP_SUMMARY
                    exit 0
                  fi

                  {
                    echo "### MongoDB Backup Trigger"
                    echo "- VM Command Output:"
                    echo '```'
                    echo "${{ steps.runbackup.outputs.stdout != '' && steps.runbackup.outputs.stdout || 'Executed (no stdout)' }}"
                    echo '```'
                    if [[ "${{ steps.runbackup.outputs.backup_file }}" != "" ]]; then
                      echo "- Backup File: ${{ steps.runbackup.outputs.backup_file }}"
                    fi
                    if [[ "${{ steps.runbackup.outputs.backup_size }}" != "" ]]; then
                      echo "- Backup Size: ${{ steps.runbackup.outputs.backup_size }}"
                    fi
                    echo "- 最新ログ抜粋:"
                    echo '```'
                    echo "${{ steps.log.outputs.log }}"
                    echo '```'
                    echo "- バックアップファイル一覧:"
                    if [[ "${{ steps.artifacts.outputs.files }}" != "" ]]; then
                      echo "${{ steps.artifacts.outputs.files }}"
                    else
                      echo "  (取得できませんでした)"
                    fi
                    DOWNLOAD_URL="${{ steps.runbackup.outputs.backup_url != '' && steps.runbackup.outputs.backup_url || steps.artifacts.outputs.public_url }}"
                    if [[ "$DOWNLOAD_URL" != "" ]]; then
                      echo "- cURL 例:"
                      echo '```'
                      if [[ "${{ steps.runbackup.outputs.backup_curl }}" != "" ]]; then
                        echo "${{ steps.runbackup.outputs.backup_curl }}"
                      else
                        echo "curl -O \"$DOWNLOAD_URL\""
                      fi
                      echo '```'
                    else
                      echo "- cURL 例: 利用可能なURLを取得できませんでした"
                    fi
                  } >> $GITHUB_STEP_SUMMARY
