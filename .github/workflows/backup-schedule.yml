name: 3. Scheduled Mongo Backup

on:
    schedule:
        # 毎日 02:00 JST に相当する 17:00 UTC に実行
        - cron: "0 17 * * *"
    workflow_dispatch:

permissions:
    contents: read
    id-token: write

env:
    RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
    MONGO_VM_NAME: ${{ vars.MONGO_VM_NAME != '' && vars.MONGO_VM_NAME || 'vm-mongo-dev' }}

jobs:
    trigger-backup:
        name: Run mongodump from Azure Automation Replacement
        runs-on: ubuntu-latest
        steps:
            - name: Azure Login
              uses: azure/login@v1
              with:
                  client-id: ${{ secrets.AZURE_CLIENT_ID }}
                  tenant-id: ${{ secrets.AZURE_TENANT_ID }}
                  subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

            - name: Execute MongoDB Backup Script on VM
              id: runbackup
              run: |
                  RG="${{ env.RESOURCE_GROUP }}"
                  VM_NAME="${{ env.MONGO_VM_NAME }}"

                  if ! az vm show --resource-group "$RG" --name "$VM_NAME" >/dev/null 2>&1; then
                    echo "::warning::VM '$VM_NAME' not found in resource group '$RG'. Skipping backup trigger."
                    {
                      echo "vm_found=false"
                      echo "stdout<<EOF"
                      echo "Skip: VM '$VM_NAME' not found in resource group '$RG'."
                      echo "EOF"
                    } >> "$GITHUB_OUTPUT"
                    exit 0
                  fi

                  OUTPUT=$(az vm run-command invoke \
                    --resource-group "$RG" \
                    --name "$VM_NAME" \
                    --command-id RunShellScript \
                    --scripts "/usr/local/bin/mongodb-backup.sh" \
                    --query "value[0].message" -o tsv)

                  echo "$OUTPUT"

                  {
                    echo "vm_found=true"
                    echo "stdout<<EOF"
                    printf '%s\n' "$OUTPUT"
                    echo "EOF"
                  } >> "$GITHUB_OUTPUT"

            - name: Collect Latest Backup Log
              id: log
              if: steps.runbackup.outputs.vm_found == 'true'
              run: |
                  RG="${{ env.RESOURCE_GROUP }}"
                  VM_NAME="${{ env.MONGO_VM_NAME }}"

                  LOG_OUTPUT=$(az vm run-command invoke \
                    --resource-group "$RG" \
                    --name "$VM_NAME" \
                    --command-id RunShellScript \
                    --scripts "tail -n 20 /var/log/mongodb-backup.log" \
                    --query "value[0].message" -o tsv)

                  {
                    echo "log<<EOF"
                    printf '%s\n' "$LOG_OUTPUT"
                    echo "EOF"
                  } >> "$GITHUB_OUTPUT"

            - name: Collect Backup Artifacts
              id: artifacts
              if: steps.runbackup.outputs.vm_found == 'true'
              run: |
                  set -euo pipefail

                  RG="${{ env.RESOURCE_GROUP }}"
                  VM_NAME="${{ env.MONGO_VM_NAME }}"

                  INFO_OUTPUT=$(az vm run-command invoke \
                    --resource-group "$RG" \
                    --name "$VM_NAME" \
                    --command-id RunShellScript \
                    --scripts "python3 <<'PY'\nimport json, os, subprocess\nbackup_dir = '/var/backups/mongodb'\nfiles = []\ntry:\n    listing = subprocess.check_output(['ls', '-lh', backup_dir], text=True)\n    for line in listing.splitlines():\n        if 'mongodb_backup_' in line:\n            parts = line.split()\n            if len(parts) >= 9:\n                files.append({'size': parts[4], 'name': parts[-1]})\nexcept Exception:\n    pass\nget_line = lambda pattern: subprocess.getoutput(f"grep '{pattern}' /var/log/mongodb-backup.log | tail -n 1")\nsas_line = get_line('SAS URL:')\npublic_line = get_line('uploaded:')\nresult = {\n    'files': files,\n    'sas': sas_line.split('SAS URL: ', 1)[1] if 'SAS URL:' in sas_line else '',\n    'public': public_line.split('uploaded: ', 1)[1] if 'uploaded:' in public_line else ''\n}\nprint(json.dumps(result))\nPY" \
                    --query "value[0].message" -o tsv)

                  JSON=$(echo "$INFO_OUTPUT" | awk '/\[stdout\]/{flag=1;next}/\[stderr\]/{flag=0}flag')
                  if [ -z "$JSON" ]; then
                    JSON="{}"
                  fi

                  FILE_LINES=$(echo "$JSON" | jq -r '.files[]? | "- \(.name) (\(.size))"' || true)
                  SAS_URL=$(echo "$JSON" | jq -r '.sas // ""' || true)
                  PUBLIC_URL=$(echo "$JSON" | jq -r '.public // ""' || true)

                  {
                    echo "files<<EOF"
                    if [ -n "$FILE_LINES" ]; then
                      echo "$FILE_LINES"
                    fi
                    echo "EOF"
                    echo "sas_url=$SAS_URL"
                    echo "public_url=$PUBLIC_URL"
                  } >> "$GITHUB_OUTPUT"

            - name: Publish Backup Summary
              run: |
                  if [[ "${{ steps.runbackup.outputs.vm_found }}" != "true" ]]; then
                    {
                      echo "### MongoDB Backup Trigger"
                      echo "- Result: VM '${{ env.MONGO_VM_NAME }}' not found in resource group '${{ env.RESOURCE_GROUP }}'. Backup skipped."
                    } >> $GITHUB_STEP_SUMMARY
                    exit 0
                  fi

                  {
                    echo "### MongoDB Backup Trigger"
                    echo "- VM Command Output:"
                    echo '```'
                    echo "${{ steps.runbackup.outputs.stdout != '' && steps.runbackup.outputs.stdout || 'Executed (no stdout)' }}"
                    echo '```'
                    echo "- Latest Log Snippet:"
                    echo '```'
                    echo "${{ steps.log.outputs.log }}"
                    echo '```'
                    echo "- Backup Files:"
                    if [[ "${{ steps.artifacts.outputs.files }}" != "" ]]; then
                      echo "${{ steps.artifacts.outputs.files }}"
                    else
                      echo "  (取得できませんでした)"
                    fi
                    DOWNLOAD_URL="${{ steps.artifacts.outputs.sas_url != '' && steps.artifacts.outputs.sas_url || steps.artifacts.outputs.public_url }}"
                    if [[ "$DOWNLOAD_URL" != "" ]]; then
                      echo "- cURL Example:"
                      echo '```'
                      echo "curl -O \"$DOWNLOAD_URL\""
                      echo '```'
                    else
                      echo "- cURL Example: 利用可能なURLを取得できませんでした"
                    fi
                  } >> $GITHUB_STEP_SUMMARY
