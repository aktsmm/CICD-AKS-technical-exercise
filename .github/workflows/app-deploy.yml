name: Build and Deploy Application

on:
    # „Ç¢„Éó„É™„Ç≥„Éº„Éâ„ÅÆ„Åø„ÅÆÂ§âÊõ¥ÊôÇ„ÅØÁõ¥Êé•ÂÆüË°å
    push:
        branches:
            - main
        paths:
            - "app/**"
            - ".github/workflows/app-deploy.yml"
    workflow_dispatch:
    # InfrastructureÂÆå‰∫ÜÂæå„Å´Ëá™ÂãïÂÆüË°å
    workflow_run:
        workflows: ["Deploy Infrastructure"]
        types:
            - completed
        branches:
            - main

permissions:
    contents: read
    security-events: write

env:
    IMAGE_NAME: ${{ vars.IMAGE_NAME }}
    RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}

jobs:
    scan-container:
        name: Scan Container Image
        runs-on: ubuntu-latest
        # Infrastructure „Éá„Éó„É≠„Ç§„ÅåÊàêÂäü„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅøÂÆüË°å
        if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
        steps:
            - name: Checkout Code
              uses: actions/checkout@v4

            - name: Build Docker Image (for scanning)
              run: |
                  cd app
                  docker build -t ${{ env.IMAGE_NAME }}:${{ github.sha }} .

            - name: Run Trivy Vulnerability Scanner
              uses: aquasecurity/trivy-action@master
              with:
                  image-ref: ${{ env.IMAGE_NAME }}:${{ github.sha }}
                  format: "sarif"
                  output: "trivy-results.sarif"
                  severity: "CRITICAL,HIGH"
              continue-on-error: true

            - name: Upload Trivy Results
              uses: github/codeql-action/upload-sarif@v3
              if: always()
              continue-on-error: true
              with:
                  sarif_file: trivy-results.sarif

    build-push:
        name: Build and Push to ACR
        runs-on: ubuntu-latest
        needs: scan-container
        # Infrastructure „Éá„Éó„É≠„Ç§„ÅåÊàêÂäü„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅøÂÆüË°å
        if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
        outputs:
            image_tag: ${{ steps.image.outputs.tag }}
            acr_name: ${{ steps.get_acr.outputs.acr_name }}
        steps:
            - name: Checkout Code
              uses: actions/checkout@v4

            - name: Azure Login
              uses: azure/login@v1
              with:
                  creds: ${{ secrets.AZURE_CREDENTIALS }}

            - name: Get ACR Name
              id: get_acr
              run: |
                  # „É™„ÇΩ„Éº„Çπ„Ç∞„É´„Éº„Éó„ÅÆÂ≠òÂú®Á¢∫Ë™çÔºàÊúÄÂ§ß10Âõû„É™„Éà„É©„Ç§„ÄÅ30ÁßíÈñìÈöîÔºâ
                  max_attempts=10
                  attempt=1

                  while [ $attempt -le $max_attempts ]; do
                      echo "üîç Attempt $attempt/$max_attempts: Checking resource group..."
                      
                      if az group show --name ${{ env.RESOURCE_GROUP }} &>/dev/null; then
                          echo "‚úÖ Resource group ${{ env.RESOURCE_GROUP }} found!"
                          break
                      fi
                      
                      if [ $attempt -eq $max_attempts ]; then
                          echo "‚ùå Resource group ${{ env.RESOURCE_GROUP }} not found after $max_attempts attempts!"
                          echo "Infrastructure deployment may not have completed yet."
                          exit 1
                      fi
                      
                      echo "‚è≥ Resource group not found. Waiting 30 seconds..."
                      sleep 30
                      attempt=$((attempt + 1))
                  done

                  # ACR„ÅÆÂèñÂæóÔºàÊúÄÂ§ß20Âõû„É™„Éà„É©„Ç§„ÄÅ30ÁßíÈñìÈöî = ÊúÄÂ§ß10ÂàÜÂæÖÊ©üÔºâ
                  max_acr_attempts=20
                  acr_attempt=1
                  ACR_NAME=""

                  while [ $acr_attempt -le $max_acr_attempts ]; do
                      echo "üîç Attempt $acr_attempt/$max_acr_attempts: Checking ACR..."
                      
                      ACR_NAME=$(az acr list --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv)
                      
                      if [ -n "$ACR_NAME" ]; then
                          echo "‚úÖ ACR found: ${ACR_NAME}"
                          break
                      fi
                      
                      if [ $acr_attempt -eq $max_acr_attempts ]; then
                          echo "‚ùå No ACR found in resource group ${{ env.RESOURCE_GROUP }} after $max_acr_attempts attempts!"
                          echo "Infrastructure deployment may still be in progress."
                          echo "üí° Hint: ACR creation typically takes 5-10 minutes after resource group creation."
                          exit 1
                      fi
                      
                      echo "‚è≥ ACR not found yet. Waiting 30 seconds... (This is normal, ACR creation takes time)"
                      sleep 30
                      acr_attempt=$((acr_attempt + 1))
                  done

                  echo "ACR Name: ${ACR_NAME}"
                  echo "acr_name=${ACR_NAME}" >> $GITHUB_OUTPUT

            - name: Login to ACR
              run: |
                  az acr login --name ${{ steps.get_acr.outputs.acr_name }}

            - name: Build and Push Image
              id: image
              run: |
                  cd app
                  IMAGE_TAG="${{ github.sha }}"
                  ACR_NAME="${{ steps.get_acr.outputs.acr_name }}"
                  FULL_IMAGE="${ACR_NAME}.azurecr.io/${{ env.IMAGE_NAME }}:${IMAGE_TAG}"

                  docker build -t $FULL_IMAGE .
                  docker push $FULL_IMAGE

                  # Tag as latest
                  docker tag $FULL_IMAGE ${ACR_NAME}.azurecr.io/${{ env.IMAGE_NAME }}:latest
                  docker push ${ACR_NAME}.azurecr.io/${{ env.IMAGE_NAME }}:latest

                  echo "tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

    deploy-aks:
        name: Deploy to AKS
        runs-on: ubuntu-latest
        needs: build-push
        # Infrastructure „Éá„Éó„É≠„Ç§„ÅåÊàêÂäü„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅøÂÆüË°å
        if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
        steps:
            - name: Checkout Code
              uses: actions/checkout@v4

            - name: Azure Login
              uses: azure/login@v1
              with:
                  creds: ${{ secrets.AZURE_CREDENTIALS }}

            - name: Get Infrastructure Details
              id: infra
              run: |
                  echo "Querying Azure for infrastructure details..."

                  # AKS„ÇØ„É©„Çπ„Çø„ÉºÂêç„ÇíÂèñÂæó
                  AKS_CLUSTER_NAME=$(az aks list -g ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv)

                  # MongoDB VM„ÅÆ„Éó„É©„Ç§„Éô„Éº„ÉàIP„ÇíÂèñÂæóÔºàVNetÂÜÖÈÄö‰ø°Áî®Ôºâ
                  MONGO_VM_IP=$(az vm list-ip-addresses -g ${{ env.RESOURCE_GROUP }} -n vm-mongo-dev --query "[0].virtualMachine.network.privateIpAddresses[0]" -o tsv)

                  echo "AKS Cluster: ${AKS_CLUSTER_NAME}"
                  echo "MongoDB VM IP: ${MONGO_VM_IP}"

                  echo "aks_name=${AKS_CLUSTER_NAME}" >> $GITHUB_OUTPUT
                  echo "mongo_ip=${MONGO_VM_IP}" >> $GITHUB_OUTPUT

            - name: Set AKS Context
              run: |
                  if [ -z "${{ steps.infra.outputs.aks_name }}" ]; then
                    echo "Error: AKS cluster name is empty. Please run infra-deploy workflow first."
                    exit 1
                  fi

                  # AKS „Åå„Éó„É≠„Éì„Ç∏„Éß„Éã„É≥„Ç∞ÂÆå‰∫Ü„Åô„Çã„Åæ„ÅßÂæÖÊ©ü
                  echo "Waiting for AKS cluster to be ready..."
                  max_attempts=30
                  attempt=1

                  while [ $attempt -le $max_attempts ]; do
                    state=$(az aks show \
                      --resource-group ${{ env.RESOURCE_GROUP }} \
                      --name ${{ steps.infra.outputs.aks_name }} \
                      --query provisioningState -o tsv)
                    
                    echo "Attempt $attempt/$max_attempts: AKS provisioning state = $state"
                    
                    if [ "$state" == "Succeeded" ]; then
                      echo "AKS cluster is ready!"
                      break
                    elif [ "$state" == "Failed" ]; then
                      echo "Error: AKS provisioning failed"
                      exit 1
                    fi
                    
                    if [ $attempt -eq $max_attempts ]; then
                      echo "Error: Timeout waiting for AKS to be ready"
                      exit 1
                    fi
                    
                    echo "Waiting 30 seconds..."
                    sleep 30
                    attempt=$((attempt + 1))
                  done

                  az aks get-credentials \
                    --resource-group ${{ env.RESOURCE_GROUP }} \
                    --name ${{ steps.infra.outputs.aks_name }} \
                    --overwrite-existing

            - name: Replace Placeholders in K8s Manifests
              run: |
                  # Deployment - use dynamic image tag from build
                  ACR_NAME="${{ needs.build-push.outputs.acr_name }}"
                  MONGO_PASSWORD="${{ secrets.MONGO_ADMIN_PASSWORD }}"

                  sed -i "s|<ACR_NAME>|${ACR_NAME}|g" app/k8s/deployment.yaml
                  sed -i "s|<IMAGE_TAG>|${{ needs.build-push.outputs.image_tag }}|g" app/k8s/deployment.yaml
                  sed -i "s|<MONGO_VM_IP>|${{ steps.infra.outputs.mongo_ip }}|g" app/k8s/deployment.yaml
                  sed -i "s|<MONGO_ADMIN_PASSWORD>|${MONGO_PASSWORD}|g" app/k8s/deployment.yaml

                  echo "=== Updated Deployment (credentials masked) ==="
                  cat app/k8s/deployment.yaml | sed "s/${MONGO_PASSWORD}/***MASKED***/g"

            - name: Deploy to Kubernetes
              run: |
                  # 1. Deploy Ingress Controller (if not exists)
                  echo "=== Deploying NGINX Ingress Controller ==="
                  kubectl apply -f app/k8s/ingress-nginx-controller.yaml

                  # Wait for Ingress Controller to be ready
                  echo "=== Waiting for Ingress Controller (2 min) ==="
                  kubectl wait --namespace ingress-nginx \
                    --for=condition=ready pod \
                    --selector=app.kubernetes.io/component=controller \
                    --timeout=120s || echo "‚ö†Ô∏è Ingress Controller not ready yet (will continue)"

                  # 2. Apply vulnerable RBAC (demo purpose)
                  echo "=== Deploying Vulnerable RBAC ==="
                  kubectl apply -f app/k8s/rbac-vulnerable.yaml

                  # 3. Deploy application
                  echo "=== Deploying Application ==="
                  kubectl apply -f app/k8s/deployment.yaml
                  kubectl apply -f app/k8s/service.yaml

                  # 4. Deploy Ingress resource
                  echo "=== Deploying Ingress ==="
                  kubectl apply -f app/k8s/ingress.yaml

            - name: Wait for Deployment
              run: |
                  echo "=== Checking Deployment Status ==="
                  kubectl get deployment guestbook-app

                  echo "=== Checking Pods ==="
                  kubectl get pods -l app=guestbook

                  echo "=== Waiting for Rollout (5 min timeout) ==="
                  kubectl rollout status deployment/guestbook-app --timeout=5m || {
                    echo "‚ùå Rollout failed or timed out. Debugging..."
                    
                    echo "=== Pod Details ==="
                    kubectl get pods -l app=guestbook -o wide
                    
                    echo "=== Pod Events ==="
                    kubectl get events --sort-by='.lastTimestamp' | grep -i guestbook || echo "No events found"
                    
                    echo "=== Pod Describe (if any pods exist) ==="
                    POD_NAME=$(kubectl get pods -l app=guestbook -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
                    if [ ! -z "$POD_NAME" ]; then
                      kubectl describe pod $POD_NAME
                      
                      echo "=== Pod Logs ==="
                      kubectl logs $POD_NAME --tail=50 || echo "No logs available"
                    fi
                    
                    echo "=== Deployment Describe ==="
                    kubectl describe deployment guestbook-app
                    
                    exit 1
                  }

            - name: Get Service Information
              run: |
                  echo "=== Pods ==="
                  kubectl get pods -l app=guestbook -o wide

                  echo "=== Services ==="
                  kubectl get svc guestbook-service

                  echo "=== Ingress Controller Service ==="
                  kubectl get svc -n ingress-nginx ingress-nginx-controller

                  echo "=== Ingress Resources ==="
                  kubectl get ingress guestbook-ingress
                  kubectl describe ingress guestbook-ingress

                  echo ""
                  echo "=== üéâ Deployment Complete ==="
                  echo "Access Flow:"
                  echo "  [User] ‚Üí [Azure Load Balancer] ‚Üí [Ingress Controller] ‚Üí [Service] ‚Üí [Pod]"
                  echo ""
                  INGRESS_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                  if [ ! -z "$INGRESS_IP" ]; then
                    echo "üåê Access URL: http://$INGRESS_IP"
                  else
                    echo "‚è≥ Waiting for External IP to be assigned..."
                  fi
