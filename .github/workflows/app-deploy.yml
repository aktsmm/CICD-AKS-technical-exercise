name: Build and Deploy Application

on:
    push:
        branches:
            - main
        paths:
            - "app/**"
            - ".github/workflows/app-deploy.yml"
    workflow_dispatch:
    workflow_run:
        workflows: ["Deploy Infrastructure"]
        types:
            - completed
        branches:
            - main

env:
    IMAGE_NAME: guestbook
    RESOURCE_GROUP: rg-wiz-exercise-a

jobs:
    scan-container:
        name: Scan Container Image
        runs-on: ubuntu-latest
        # Infrastructure デプロイが成功した場合のみ実行
        if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
        steps:
            - name: Checkout Code
              uses: actions/checkout@v4

            - name: Build Docker Image (for scanning)
              run: |
                  cd app
                  docker build -t ${{ env.IMAGE_NAME }}:${{ github.sha }} .

            - name: Run Trivy Vulnerability Scanner
              uses: aquasecurity/trivy-action@master
              with:
                  image-ref: ${{ env.IMAGE_NAME }}:${{ github.sha }}
                  format: "sarif"
                  output: "trivy-results.sarif"
                  severity: "CRITICAL,HIGH"
              continue-on-error: true

            - name: Upload Trivy Results
              uses: github/codeql-action/upload-sarif@v3
              if: always()
              continue-on-error: true
              with:
                  sarif_file: trivy-results.sarif

    build-push:
        name: Build and Push to ACR
        runs-on: ubuntu-latest
        needs: scan-container
        outputs:
            image_tag: ${{ steps.image.outputs.tag }}
            acr_name: ${{ steps.get_acr.outputs.acr_name }}
        steps:
            - name: Checkout Code
              uses: actions/checkout@v4

            - name: Azure Login
              uses: azure/login@v1
              with:
                  creds: ${{ secrets.AZURE_CREDENTIALS }}

            - name: Get ACR Name
              id: get_acr
              run: |
                  ACR_NAME=$(az acr list --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv)
                  echo "ACR Name: ${ACR_NAME}"
                  echo "acr_name=${ACR_NAME}" >> $GITHUB_OUTPUT

            - name: Login to ACR
              run: |
                  az acr login --name ${{ steps.get_acr.outputs.acr_name }}

            - name: Build and Push Image
              id: image
              run: |
                  cd app
                  IMAGE_TAG="${{ github.sha }}"
                  ACR_NAME="${{ steps.get_acr.outputs.acr_name }}"
                  FULL_IMAGE="${ACR_NAME}.azurecr.io/${{ env.IMAGE_NAME }}:${IMAGE_TAG}"

                  docker build -t $FULL_IMAGE .
                  docker push $FULL_IMAGE

                  # Tag as latest
                  docker tag $FULL_IMAGE ${ACR_NAME}.azurecr.io/${{ env.IMAGE_NAME }}:latest
                  docker push ${ACR_NAME}.azurecr.io/${{ env.IMAGE_NAME }}:latest

                  echo "tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

    deploy-aks:
        name: Deploy to AKS
        runs-on: ubuntu-latest
        needs: build-push
        steps:
            - name: Checkout Code
              uses: actions/checkout@v4

            - name: Azure Login
              uses: azure/login@v1
              with:
                  creds: ${{ secrets.AZURE_CREDENTIALS }}

            - name: Download Infra Outputs
              uses: actions/download-artifact@v4
              with:
                  name: infra-outputs
              continue-on-error: true

            - name: Get Infrastructure Details
              id: infra
              run: |
                  # Try to load from artifact first
                  if [ -f outputs/infra-outputs.txt ]; then
                    echo "Loading from artifact..."
                    source outputs/infra-outputs.txt
                  else
                    echo "Artifact not found, querying Azure directly..."
                    # Fallback: Query Azure directly
                    AKS_CLUSTER_NAME=$(az aks list -g ${{ env.RESOURCE_GROUP }} --query "[0].name" -o tsv)
                    MONGO_VM_IP=$(az vm list-ip-addresses -g ${{ env.RESOURCE_GROUP }} -n vm-mongo-dev --query "[0].virtualMachine.network.publicIpAddresses[0].ipAddress" -o tsv)
                  fi

                  echo "AKS Cluster: ${AKS_CLUSTER_NAME}"
                  echo "MongoDB VM IP: ${MONGO_VM_IP}"

                  echo "aks_name=${AKS_CLUSTER_NAME}" >> $GITHUB_OUTPUT
                  echo "mongo_ip=${MONGO_VM_IP}" >> $GITHUB_OUTPUT

            - name: Set AKS Context
              run: |
                  if [ -z "${{ steps.infra.outputs.aks_name }}" ]; then
                    echo "Error: AKS cluster name is empty. Please run infra-deploy workflow first."
                    exit 1
                  fi

                  # AKS がプロビジョニング完了するまで待機
                  echo "Waiting for AKS cluster to be ready..."
                  max_attempts=30
                  attempt=1

                  while [ $attempt -le $max_attempts ]; do
                    state=$(az aks show \
                      --resource-group ${{ env.RESOURCE_GROUP }} \
                      --name ${{ steps.infra.outputs.aks_name }} \
                      --query provisioningState -o tsv)
                    
                    echo "Attempt $attempt/$max_attempts: AKS provisioning state = $state"
                    
                    if [ "$state" == "Succeeded" ]; then
                      echo "AKS cluster is ready!"
                      break
                    elif [ "$state" == "Failed" ]; then
                      echo "Error: AKS provisioning failed"
                      exit 1
                    fi
                    
                    if [ $attempt -eq $max_attempts ]; then
                      echo "Error: Timeout waiting for AKS to be ready"
                      exit 1
                    fi
                    
                    echo "Waiting 30 seconds..."
                    sleep 30
                    attempt=$((attempt + 1))
                  done

                  az aks get-credentials \
                    --resource-group ${{ env.RESOURCE_GROUP }} \
                    --name ${{ steps.infra.outputs.aks_name }} \
                    --overwrite-existing

            - name: Replace Placeholders in K8s Manifests
              run: |
                  # Deployment - use dynamic image tag from build
                  ACR_NAME="${{ needs.build-push.outputs.acr_name }}"
                  sed -i "s|image: acrwiz.*\.azurecr\.io/guestbook:.*|image: ${ACR_NAME}.azurecr.io/${{ env.IMAGE_NAME }}:${{ needs.build-push.outputs.image_tag }}|g" app/k8s/deployment.yaml
                  sed -i "s|<MONGO_VM_IP>|${{ steps.infra.outputs.mongo_ip }}|g" app/k8s/deployment.yaml

                  echo "=== Updated Deployment ==="
                  cat app/k8s/deployment.yaml

            - name: Deploy to Kubernetes
              run: |
                  # Apply vulnerable RBAC first (demo purpose)
                  kubectl apply -f app/k8s/rbac-vulnerable.yaml

                  # Deploy application
                  kubectl apply -f app/k8s/deployment.yaml
                  kubectl apply -f app/k8s/service.yaml
                  # Note: Ingress is skipped as we're using LoadBalancer service type

            - name: Wait for Deployment
              run: |
                  kubectl rollout status deployment/guestbook-app --timeout=5m

            - name: Get Service Information
              run: |
                  echo "=== Pods ==="
                  kubectl get pods -l app=guestbook

                  echo "=== Services ==="
                  kubectl get svc guestbook-service

                  echo "=== Deployment Complete ==="
                  echo "Access the application via the LoadBalancer EXTERNAL-IP shown above"
